"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const enforcer_1 = require("./enforcer");
// CachedEnforcer wraps Enforcer and provides decision cache
class CachedEnforcer extends enforcer_1.Enforcer {
    constructor() {
        super(...arguments);
        this.enableCache = true;
        this.m = new Map();
    }
    // invalidateCache deletes all the existing cached decisions.
    invalidateCache() {
        this.m = new Map();
    }
    // setEnableCache determines whether to enable cache on e nforce(). When enableCache is enabled, cached result (true | false) will be returned for previous decisions.
    setEnableCache(enableCache) {
        this.enableCache = enableCache;
    }
    static canCache(...rvals) {
        return rvals.every(n => typeof n === 'string');
    }
    static getCacheKey(...rvals) {
        return rvals.join('$$');
    }
    getCache(key) {
        return this.m.get(key);
    }
    setCache(key, value) {
        this.m.set(key, value);
    }
    // enforce decides whether a "subject" can access a "object" with the operation "action", input parameters are usually: (sub, obj, act).
    // if rvals is not string , ingore the cache
    enforce(...rvals) {
        const _super = Object.create(null, {
            enforce: { get: () => super.enforce }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.enableCache) {
                return _super.enforce.call(this, ...rvals);
            }
            let key = '';
            const cache = CachedEnforcer.canCache(...rvals);
            if (cache) {
                key = CachedEnforcer.getCacheKey(...rvals);
                const res = this.getCache(key);
                if (res != undefined) {
                    return res;
                }
            }
            const res = yield _super.enforce.call(this, ...rvals);
            if (cache) {
                this.setCache(key, res);
            }
            return res;
        });
    }
}
exports.CachedEnforcer = CachedEnforcer;
// newCachedEnforcer creates a cached enforcer via file or DB.
function newCachedEnforcer(...params) {
    return __awaiter(this, void 0, void 0, function* () {
        return enforcer_1.newEnforcerWithClass(CachedEnforcer, ...params);
    });
}
exports.newCachedEnforcer = newCachedEnforcer;
