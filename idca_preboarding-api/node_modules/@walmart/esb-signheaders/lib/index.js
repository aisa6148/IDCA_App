'use strict';

// Load Modules

const Crypto = require('crypto');
const FS = require('fs');
const Hoek = require('hoek');


//Declare Internals

const internals = {
    defaults: {
        algorithm: 'RSA-SHA256',
        encoding: 'base64'
    },
    mandatoryHeaders: ['wm_consumer.id', 'wm_sec.key_version'],
    signedHeaderName: 'SignedHeaders',
    signatureHeaderName: 'WM_SEC.AUTH_SIGNATURE',
    pemHeader: '-----BEGIN PRIVATE KEY-----',
    pemFooter: '-----END PRIVATE KEY-----',
    pemLineLength: 64
};


module.exports = internals.ESH = function (options) {

    this._config = Hoek.applyToDefaults(internals.defaults, options || {});

    if (this._config.privateKey) {
        this._config.pemKey = internals.toPEMFormat(options.privateKey);
    }

    if (this._config.pemFile) {
        this._config.pemKey = FS.readFileSync(options.pemFile, 'ascii');
    }

    Hoek.assert(this._config.pemKey, 'privateKey or valid PEM file not provided');
};


internals.ESH.prototype.sign = function (headers) {

    Hoek.assert(internals.hasMandatoryHeaders(headers), 'mandatory headers are not found (' + (internals.mandatoryHeaders.join(',')) + ')');

    const signedHeaders = Hoek.clone(headers);

    signedHeaders[internals.signedHeaderName] = 'WM_CONSUMER.ID;WM_CONSUMER.INTIMESTAMP;WM_SEC.KEY_VERSION;';
    signedHeaders['WM_CONSUMER.INTIMESTAMP'] = internals.getValue(signedHeaders, 'wm_consumer.intimestamp') || new Date().getTime();

    const values = [];
    values.push(internals.getValue(signedHeaders, 'wm_consumer.id'));
    values.push(internals.getValue(signedHeaders, 'wm_consumer.intimestamp'));
    values.push(internals.getValue(signedHeaders, 'wm_sec.key_version'));
    const value = values.join('\n') + '\n';

    const sha256 = Crypto.createSign(this._config.algorithm);
    sha256.update(value);
    const signature = sha256.sign(this._config.pemKey, this._config.encoding);
    signedHeaders[internals.signatureHeaderName] = signature.toString();

    return signedHeaders;
};


internals.hasMandatoryHeaders = function (headers) {

    const keys = headers && Object.keys(headers);

    if (keys && keys.length > 0) {
        let numFound = 0;
        for (let i = 0; i < keys.length; ++i) {
            if (internals.mandatoryHeaders.indexOf(keys[i].toLowerCase()) > -1) {
                ++numFound;
            }
        }

        if (numFound === internals.mandatoryHeaders.length) {
            return true;
        }
    }

    return false;
};


internals.toPEMFormat = function (privateKey) {

    const key64 = privateKey.match(/.{1,64}/g);
    const pemPrivateKey = [internals.pemHeader].concat(key64).concat([internals.pemFooter]);
    return pemPrivateKey.join('\n') + '\n';
};


internals.getValue = function (inbound, name) {

    return inbound[name] || inbound[name.toUpperCase()];
};
